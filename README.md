yandex-tank-api
===============

Yandex.Tank API is an HTTP server that provides a REST-like API to control Yandex.Tank execution from a remote host.
Its main purpose is synchronization of Yandex.Tank test stages on multiple load generators.

Yandex.Tank basics
------------------

### Test sequence

When a new session is created, a separate tank process is spawned. After this, the test stages are executed in the following order:
  1. **lock**
     Attempt to acquire the tank lock. This stage fails if another test started via console or API is running.
  2. **init**
     Logging is set up and tank configuration files are read at this stage.
  3. **configure**
     The *configure()* method is called for each module. Most of the dynamic configuration is done here.
  4. **prepare**
     The *prepare_test()* method is called for each module. Heavy and time-consuming tasks (such as stpd-file generation and monitoring agent setup) are done here.
  5. **start**
     The *start_test()* method is called for each module. This should take as little time as possible. Load generation begins at this moment.
  6. **poll**
     Once per second the *is_test_finished()* method is called for each module. This stage ends when any of the modules requests to stop the test.
  7. **end** 
     The *end_test()* method is called for each module. This should take as little time as possible.
  8. **postprocess**
     The *post_process()* method is called for each module. Heavy and time-consuming tasks are performed here.
  9. **unlock**
     The tank lock is released and tank process exits.
  10. **finished**
     This is a virtual stage, the tank process has already terminated.

### Pausing the test sequence
When the session is started, the client can specify the test stage before which the test will be paused (the breakpoint) . 
After completing the stages preceding the breakpoint, the Tank will wait until the breakpoint is moved further. You cannot move the breakpoint back. 

The breakpoint can be set before any stage. One of the most frequent use cases is to set the breakpoint at start stage to synchhonize several tanks.
Another is setting the breakpoint at the unlock stage to download the artifacts without interference from other tests.
Beware that setting the breakpoint at the **poll** stage can lead to very exotic behaviour.

API requests
-----------

All API requests are asynchronous. HTTP code 200 is returned when no error occured while processing the request. 
However, this does not necessary mean that the requested action will be successfully performed. 
The client should check the session status to detect Tank failures.

All handles, except for /artifact, return JSON. On errors this is a JSON object with a key 'reason'.

### List of API requests
1. POST /run?[test=...]&[break=...]
Request body: Yandex.Tank config in .ini format (the same as for console Tank)

Creates a new session with a unique *session ID* and launches a new Tank process.

Parameters:
  * test: ID of the *test*. Should be a valid directory name. *Default: randomly generated UUID.*
  * break: the test stage before which the tank will stop and wait until the next break is set. *Default: "finished"*

Reply on success:     
`
{
"test": test ID (either specified by client or autogenerated),
"session": ID of the launched session
}
`

Error codes and corresponding reasons in the reply:
  * 400, 'Specified break is not a valid test stage name.' 
  * 409, 'The test with this ID is already running.'
  * 409, 'The test with this ID has already finished.'
  * 503, 'Another session is already running.'

2. GET /run?session=...&[break=...]

Sets a new break point for the running session.

Parameters:
  * session: session ID
  * break: the test stage before which the tank will stop and wait until the next break is set. *Default: "finished"*

Return codes and corresponding reasons:
  * 200, 'Will try to set break before [new break point]'
  * 400, 'Specified break is not a valid test stage name.'           
  * 404, 'No session with this ID.'
  * 418, ... (returned when client tries to move the break point back)
  * 500, 'Session failed.'

3. GET /stop?session=...

Terminates the current test.

Parameters:
  * session: ID of the session to terminate

Return codes and corresponding reasons:
  * 200, 'Will try to stop tank process.'
  * 404, 'No session with this ID.'
  * 409, 'This session is already stopped.'

4. GET /status?session=...

Returns the status of the specified session.

Parameters:
  * session: ID of the session.

Error code and the corresponding reason:
  * 404, 'No session with this ID.'

5. GET /status?

Returns a JSON object where keys are known session IDs and values are the corresponding statuses.

6. GET /artifact?test=...

Returns a JSON array of artifact filenames.

Parameters:
  * test: ID of the test

Error codes and the corresponding reasons:
  * 404, 'No test with this ID found'
  * 404, 'Test was not performed, no artifacts.'


7. GET /artifact?test=...&filename=...

Sends the specified file to the client.

Parameters:
  * test: ID of the test
  * filename: the artifact file name

Error codes and the corresponding reasons:
  * 404, 'No test with this ID found'
  * 404, 'Test was not performed, no artifacts.'
  * 404, 'No such file'
  * 503, 'File is too large and test is running' (when the file size exceeds 128 kB and test is running)





 
